#' generate.model.set
#'
#' Generate a complete full subsets model set for analysis based on gam(m4) via a call to fit.model.set.
#' @param use.dat A data.frame, with columns matching those included in pred.vars.cont and pred.vars.fact, the response variable to be analysed and any other fields required for the analysis (such as random effects, see test.fit). Note that any variables in use.dat that are used in model fits must not contain missing values, as this invalidates comparison via AICc/ BIC. If missing values occur among the predictor variables the function will return an error warning indicating that these rows need to be removed or interpolated.
#'
#' @param test.fit A gam model fitted via a call to gam (mgcv) or uGamm (MuMIn). This can use any of the (preferably continuous) predictors in the call and will be used as a model to update in the fitting of the model set.
#' The test fit must contain the appropriate random effects and call to family (if not gaussian) and if gamm4 should be used, or gamm in the case of a uGamm call (see ?uGamm).
#' Both gamm from mgcv and gamm4 have slightly different features, as well as advantages and disadvantages, thus it is important that the full subsets function is able to deal with test.fit models based on either package. For example gamm4 is based on the lme4 package [Bates, D.M. (2010) lme4: Mixed-Effects Modeling with R. Springer, New York] which allows crossed random effects and avoids issues with PQL for non-gaussian model fits. On the other hand gamm (mgcv) is based on nlme which allows correlation structures [Box, G.E.P., Jenkins, G.M., and Reinsel G.C. (1994) "Time Series Analysis: Forecasting and Control", 3rd Edition, Holden-Day], variance structures [Pinheiro, J.C. and Bates., D.M. (1996) "Unconstrained Parametrizations for Variance-Covariance Matrices", Statistics and Computing, 6, 289-296], and a broader range of families that are not yet available in lmer (see ?family.mgcv).
#' Models that have no random effects and are based only on gam (mgcv) are best fit via a direct call to gam, rather than using the uGamm wrapper.
#'
#' @param pred.vars.cont A character vector indicating the continuous predictors to use. By default all continuous predictors will be fitted using a smoother (but see argument linear.vars). These must match column names in use.dat exactly. If NA is used the function can be run without any smooth predictors.
#'
#' @param factor.factor.interactions A logical value indicating if interactions between factors should be included, or only their main effects. Defaults to FALSE. Note that this can substantially increase the number of models in the candidate set. Not recommended when there are factors with many levels. Alternatively character vector specifying which factor predictors to include as interactions. These must be contained within pred.vars.fact.
#' If factor.factor.interactions is set to TRUE the function automatically generates hard coded interaction variables up to the maximum number of predictors (see max.predictors below) using combn. New factors are generated by pasting the resulting unique combinations together. This method of generating interaction terms is necessary because smooth-factor interactions are specified as by arguments in calls to gam(m4). Because the full subsets function automatically checks for collinearity, there is no issue with constructing model sets with multiple factor arguments that are higher order factors of each other, as these are invariably collinear and subsequently removed (see cov.cutoff below). If a user defined cor.matrix is passed to the function (see cor.matrix) this must include these hard coded interactions.
#'
#' @param smooth.smooth.interactions A logical value indicating if the function should include te smooths of second order continuous predictor interactions. If set to TRUE, all continuous predictors will be combined as bivariate calls to te. Alternatively character vector specifying which continuous predictors to include. These must be contained within pred.vars.cont.
#'
#' @param factor.smooth.interactions Default is the character vector pred.vars.fact, meaning that all factor predictors will be included as by arguments with all the continuous predictors. If factor.factor.interactions is TRUE, factor interactions variables will also be included as by arguments, yielding higher order interactions up to the specified model max.predictors. If a character vector is supplied, this must specify which factor variables should be included as "by" argument interaction terms with the continuous smooth predictors. If a list is supplied, this must be a named list containing the elements fact.vars, linear.vars, cont.vars, each a character vector indicating what predictors should be used to construct the factor smooth interactions. Note that specified factors, linear predictors and continuous predictors must also be included in their respective character vectors (pred.vars.fact, linear.vars, pred.vars.cont). If specified as NA no factor-continuous predictor interactions will be included.
#'
#' @param  max.predictors An integer indicating the maximum number of predictors to include in any one model.
#'
#' @param  cov.cutoff A numeric value between 0 and 1 indicating the correlation cutoff value to use for excluding collinear models, based on the cor.matrix (see below). The default value is 0.28 (see Graham MH (2003). It is highly recommended to keep this value low, as correlation among predictors can yield spurious results. Note that predictors with a correlation greater than the specified value will still appear in the model set but will never appear in the same model. Including highly correlated predictors can make interpreting variable importance values difficult.
#'
#' @param cor.matrix  By default predictor correlations are evaluated via a call to check.correlations, a function taking a data.frame (containing all predictors) as argument and generating a correlation matrix comprised of: 1) correlation coefficients between all continuous predictors via a call to cor; 2) approximate correlation values between continuous predictors and factors, as the square-route of the R2 value obtained via a call to lm, where the continuous predictor is modelled as a response and the factor variable as a single fixed factor; and 3) approximate correlations values between factor predictors, as the square-route of the R2 value obtained via a call multinom (from package nnet, Venables & Ripley 2002). Note that any user constructed pairwise matrix can be passed to the function and used for pairwise exclusion of variables from individual models.
#'
#' @param non.linear.correlations Set this argument to TRUE of you would like to exclude continuous predictor combinations that are potentially "correlated" through non-linear relationships. See ?check.non.linear.correlations for more details.
#'
#' @param k An integer indicating the dimension of the basis used to represent the smooth term (see ?s). The default value is 5. Higher values are not recommended unless a complex trend between the response variable and the continuous predictor variables is expected, and the data are sufficient to support this. k can be reduced to as low as 3 where there is trouble obtaining convergence, or sample size is low. Note that this must be set to override the default value, regardless of what k is used in the test.fit
#'
#' @param bs.arg Specification of the smoother to use, see ?s for more information on smoother provided in gam (mgcv). Note that all continuous predictors specified in pred.vars.cont will be fitted using the same smooth, unless they are also specified as linear.terms or cyclic.vars. Note that any specification of bs in test.fit is discarded.
#'
#' @param cyclic.vars NA if there are no cyclic predictors, or if there are cyclic predictors, a character vector containing the names of any of the continuous predictors that should be modelled as cyclic variables. Note that these must also be contained in the pred.vars.cont charactervector. Please also note there are issues with bs='cc' and model selection as this uses by default shrinkage. With shrinkage, variables are retained in models but with zero edf, which makes interpretation of AICc and BIC confusing. To account for this always select only the most parsimonious model (that with the fewest parameters), not just that with the lowest AICc. Reported estimated degrees of freedom (edf) in the model output table represent the sum of the edf of the smooth terms plus the number of parametric coefficients. When cyclic variables are included and shrinkage is used, any estimated edf of the smooth terms that are less than 1 are reset to 1 before summing to ensure the the total number of predictors in the model is captured properly.
#'
#' @param linear.vars NA if there are no continuous predictors to be treated as linear (not fitted as smooths). Only use this where variables are clearly continuous in nature, but you are confident a linear relationship is valid. It may also be useful for continuous predictors that are not well distributed along the x-axis (ie, sampling was conducted in clumped distances from a feature of interest). Where this is necessary, transformations should be considered where they can be used to theoretically linearize response relationships. Does not need to be contained in vector pred.vars.cont
#'
#' @param null.terms A character vector indicating the form of any re smooths to be included in gam [e.g. s(site,bs=re)] or any other fixed terms or smooths that the user wants to include in the null model. Use of bs=re is an alternative way of fitting simple random structures that avoids use of PQL and allows a the greater range of families available in gam.mgcv to be used. see ?s and links therein. Note: make sure you use gam instead of uGamm to make sure PQL is not used.
#'
#' @details The function constructs a complete model set based on the supplied arguments.
#' for more information see Fisher R, Wilson SK, Sin TM, Lee AC, Langlois TJ (2018) A simple function for full-subsets multiple regression in ecology with R. Ecology and Evolution
#' https://onlinelibrary.wiley.com/doi/abs/10.1002/ece3.4134
#' @export
#' @return A list of the following output files:
#'
#' used.data - A data.frame which is identical to the data.frame initially supplied by the user, but with any hard coded interaction terms appended via cbind.
#'
#' predictor.correlations - The matrix of estimated predictor correlations returned by the function check.correlations and used for model exclusion based on cov.cutoff
#'
#' generated.models - A list containing the model formula that were generated (and will be fitted by fit.model.set).


generate.model.set=function(use.dat,
                          test.fit,
                          pred.vars.cont=NA,
                          pred.vars.fact=NA,
                          cyclic.vars=NA,
                          linear.vars=NA,
                          factor.smooth.interactions=pred.vars.fact,
                          factor.factor.interactions=F,
                          smooth.smooth.interactions=F,
                          cov.cutoff=0.28,
                          cor.matrix=NA,
                          non.linear.correlations=F,
                          max.predictors=3,
                          k=5,
                          bs.arg="'cr'",
                          null.terms=""){
  # make sure use.dat is a data.frame
  use.dat=as.data.frame(use.dat)

  # make an "intercept" term for the null model
  use.dat$intercept=1
  interaction.terms=NA
  linear.interaction.terms=NA
  all.predictors=unique(na.omit(c(pred.vars.cont,pred.vars.fact,linear.vars)))
  included.vars=all.predictors


  # check the null model will fit
  if(nchar(null.terms)>0){
    null.formula=as.formula(paste("~ intercept-1",null.terms,sep="+"))}else{
    null.formula=as.formula("~ intercept-1")}

  if(length(grep("dsm",class(test.fit)))>0){
    null.formula=as.formula(paste("~1",null.terms,sep="+"))
    null.fit=try(update(test.fit,formula=null.formula),silent=T)
  }else{
    null.fit=try(update(test.fit,formula=null.formula,data=use.dat),silent=T)}

  if(class(null.fit)[1]=="try-error"){
        stop(paste("Null model not successfully fitted, please check your inputs.
                   If there are no random effects try using 'gam' instead of 'uGamm'
                   in your test.fit model call.",
                   " ",
                   "The following error message was provided:  ",
                   "  ",
                   null.fit, ""))}

  # check for missing predictor values
  if(max(is.na(use.dat[,all.predictors]))==1){
        stop("Predictor variables contain NA and AICc/BIC comparisons are invalid.
        Remove rows with NA from the input data or interpolate missing predictors.")}

  # make the interaction terms vector
  interaction.terms=NA

  # if there are factors
  if(length(na.omit(pred.vars.fact))>0){
  # if there are two or more factors
  if(length(na.omit(pred.vars.fact))>1){
    # make all the interactions between factors
    if(class(factor.factor.interactions)=="logical"){
     if(factor.factor.interactions==T){
        if(length(pred.vars.fact)<2){
            stop("You have less than 2 factors. Please reset 'factor.factor.interactions' to 'False'")}
      factor.correlations=check.correlations(use.dat[,pred.vars.fact])
      fact.combns=list()
      fact.cmbns.max.predictors=max.predictors
      if(max.predictors>length(pred.vars.fact)){fact.cmbns.max.predictors=length(pred.vars.fact)}
      for(i in 2:fact.cmbns.max.predictors){
        if(i<=length(pred.vars.fact)){
        fact.combns=c(fact.combns,
         combn(pred.vars.fact,i,simplify=F)) }}
        # check which were correlated
        fact.combns=lapply(fact.combns,FUN=function(x){
                row.index=which(match(rownames(factor.correlations),x)>0)
                col.index=which(match(colnames(factor.correlations),x)>0)
                cor.mat.m=factor.correlations[row.index,col.index]
                out=x
                if(max(abs(cor.mat.m[upper.tri(cor.mat.m)]))>cov.cutoff){out=NA}
                if(max(abs(cor.mat.m[lower.tri(cor.mat.m)]))>cov.cutoff){out=NA}                
                return(out)})
        fact.combns[which(is.na(fact.combns))]=NULL
        tt=data.frame(lapply(fact.combns,FUN=function(x){
                   do.call("paste",as.list(use.dat[,x]))}))
        factor.interaction.terms=unlist(lapply(fact.combns,FUN=paste,collapse=".I."))
        colnames(tt)=factor.interaction.terms
      if(ncol(tt)>0){
        use.dat=cbind(use.dat,tt)
      }else{
        warning("You have set factor.factor.interactions to 'TRUE' but there are no 
                factors to interaction at your specified cor.cuttoff value.")}
      
      pred.vars.fact=c(pred.vars.fact,factor.interaction.terms)
      }
    }
    # make only specified interactions between factors
    if(class(factor.factor.interactions)=="character"){
        if(length(factor.factor.interactions)<2){
            stop("You specified less than 2 factors as factor.factor.interactions.")}
        if(max(is.na(match(factor.factor.interactions,colnames(use.dat))))==1){
            stop("Not all specified factor.factor.interactions are supplied in use.dat")}
      factor.correlations=check.correlations(use.dat[,factor.factor.interactions])
      #if(min(factor.correlations,na.rm=T)>cov.cutoff){
      #   stop("All factors have a correlation higher than your cutoff value")}
      if(length(which(factor.correlations<cov.cutoff))>1){
        fact.combns=list()
        fact.cmbns.max.predictors=max.predictors
        if(max.predictors>length(factor.factor.interactions)){fact.cmbns.max.predictors=length(factor.factor.interactions)}
        for(i in 2:fact.cmbns.max.predictors){
          if(i<=length(factor.factor.interactions)){
          fact.combns=c(fact.combns,
           combn(factor.factor.interactions,i,simplify=F)) }}
          # check which were correlated
          fact.combns=lapply(fact.combns,FUN=function(x){
                  row.index=which(match(rownames(factor.correlations),x)>0)
                  col.index=which(match(colnames(factor.correlations),x)>0)
                  cor.mat.m=factor.correlations[row.index,col.index]
                  out=x
                  if(max(abs(cor.mat.m[upper.tri(cor.mat.m)]))>cov.cutoff){out=NA}
                  return(out)})
          fact.combns[which(is.na(fact.combns))]=NULL
          tt=data.frame(lapply(fact.combns,FUN=function(x){
                     do.call("paste",as.list(use.dat[,x]))}))
          factor.interaction.terms=unlist(lapply(fact.combns,FUN=paste,collapse=".I."))
          colnames(tt)=factor.interaction.terms

        use.dat=cbind(use.dat,tt)
        pred.vars.fact=c(pred.vars.fact,factor.interaction.terms)
      }
    }
   }
   # make sure the factors are factors
   for(f in 1:length(pred.vars.fact)){
       use.dat[,pred.vars.fact[f]]=factor(use.dat[,pred.vars.fact[f]])}


   # check which factors should be included as interactions with the smoothers
   # for if only factors are specified (including default)
   if(class(factor.smooth.interactions)=="character"){

     factor.smooth.interactions=pred.vars.fact[which(unlist(lapply(strsplit(pred.vars.fact,
        split=".I."),function(x){
        max(is.na(match(x,factor.smooth.interactions)))}))==0)]
     # make the interaction terms between the factors and continuous predictors

     if(length(na.omit(factor.smooth.interactions))>0){
      all.interactions=expand.grid(pred.vars.cont,factor.smooth.interactions)
      interaction.terms=paste(all.interactions$Var1,all.interactions$Var2,sep=".by.")

      # now interactions between linear continous predictors and factors
      if(length(na.omit(linear.vars))>0){
       linear.interactions=expand.grid(linear.vars,factor.smooth.interactions)
       linear.interaction.terms=paste(linear.interactions$Var1,linear.interactions$Var2,
                                  sep=".t.")}
      }
    }
   if(class(factor.smooth.interactions)=="list"){


     check.list=match(unlist(factor.smooth.interactions),all.predictors)


     if(length(which(is.na(check.list)))>0){
             stop(paste("Variable(s)",
                        unlist(factor.smooth.interactions)[which(is.na(check.list))] ,
                        "included in the factor.smooth.interactions list do(es)
                        not appear in either pred.vars.fact, pred.vars.cont or linear.vars.
                        Pleasure ensure all predictors are specified as one of these three types"))}

     cont.var.interactions=factor.smooth.interactions$cont.vars
     linear.var.interactions=factor.smooth.interactions$linear.vars
     factor.smooth.interactions=factor.smooth.interactions$fact.vars

     factor.smooth.interactions=pred.vars.fact[which(unlist(lapply(strsplit(pred.vars.fact,
        split=".I."),function(x){
        max(is.na(match(x,factor.smooth.interactions)))}))==0)]
     # make the interaction terms between the factors and continuous predictors

     if(length(na.omit(factor.smooth.interactions))>0){
      all.interactions=expand.grid(cont.var.interactions,factor.smooth.interactions)
      interaction.terms=paste(all.interactions$Var1,all.interactions$Var2,sep=".by.")

      # now interactions between linear continous predictors and factors
      if(length(na.omit(linear.var.interactions))>0){
       linear.interactions=expand.grid(linear.var.interactions,factor.smooth.interactions)
       linear.interaction.terms=paste(linear.interactions$Var1,linear.interactions$Var2,
                                  sep=".t.")}
      }
    }

   }

   # if we want smooth.smooth interactions
   smooth.smooth.interaction.terms=NA
    # for interactions amonst all continuous predictors
    if(class(smooth.smooth.interactions)=="logical"){
      if(smooth.smooth.interactions==T){
        if(length(pred.vars.cont)<2){
            stop("You have less than 2 continuous predictors you wish interactions for.
            Please reset 'smooth.smooth.interactions' to 'False'")}
       if(non.linear.correlations==T){
        continuous.correlations=check.non.linear.correlations(use.dat[,pred.vars.cont])}else{
        continuous.correlations=check.correlations(use.dat[,pred.vars.cont])}

      cont.combns=list()
      cont.cmbns.max.predictors=2#max.predictors
      #if(max.predictors>length(pred.vars.cont)){cont.cmbns.max.predictors=length(pred.vars.cont)}
      for(i in 2:cont.cmbns.max.predictors){
        if(i<=length(pred.vars.cont)){
        cont.combns=c(cont.combns,
         combn(pred.vars.cont,i,simplify=F)) }}
        # check which were correlated
        cont.combns=lapply(cont.combns,FUN=function(x){
                row.index=which(match(rownames(continuous.correlations),x)>0)
                col.index=which(match(colnames(continuous.correlations),x)>0)
                cor.mat.m=continuous.correlations[row.index,col.index]
                out=x
                if(max(abs(cor.mat.m[upper.tri(cor.mat.m)]))>cov.cutoff){out=NA}
                return(out)})
        cont.combns[which(is.na(cont.combns))]=NULL
        tt=data.frame(lapply(cont.combns,FUN=function(x){
                   do.call("paste",as.list(use.dat[,x]))}))
        smooth.smooth.interaction.terms=unlist(lapply(cont.combns,FUN=paste,collapse=".te."))
        colnames(tt)=smooth.smooth.interaction.terms
     }
    }
    # for only specific interactions amonst continuous predictors
    if(class(smooth.smooth.interactions)=="character"){
        if(length(smooth.smooth.interactions)<2){
            stop("You specified less than 2 variables as smooth.smooth.interactions.")}
        if(max(is.na(match(smooth.smooth.interactions,colnames(use.dat))))==1){
            stop("Not all specified smooth.smooth.interactions are supplied in use.dat")}
      if(non.linear.correlations==T){
       continuous.correlations=check.non.linear.correlations(use.dat[,smooth.smooth.interactions])}else{
       continuous.correlations=check.correlations(use.dat[,smooth.smooth.interactions])}

      cont.combns=list()
      cont.cmbns.max.predictors=max.predictors
      if(max.predictors>length(smooth.smooth.interactions)){cont.cmbns.max.predictors=length(smooth.smooth.interactions)}
      for(i in 2:cont.cmbns.max.predictors){
        if(i<=length(smooth.smooth.interactions)){
        cont.combns=c(cont.combns,
         combn(smooth.smooth.interactions,i,simplify=F)) }}
        # check which were correlated
        cont.combns=lapply(cont.combns,FUN=function(x){
                row.index=which(match(rownames(continuous.correlations),x)>0)
                col.index=which(match(colnames(continuous.correlations),x)>0)
                cor.mat.m=continuous.correlations[row.index,col.index]
                out=x
                if(max(abs(cor.mat.m[upper.tri(cor.mat.m)]))>cov.cutoff){out=NA}
                return(out)})
        cont.combns[which(is.na(cont.combns))]=NULL
        tt=data.frame(lapply(cont.combns,FUN=function(x){
                   do.call("paste",as.list(use.dat[,x]))}))
        smooth.smooth.interaction.terms=unlist(lapply(cont.combns,FUN=paste,collapse=".te."))
        colnames(tt)=smooth.smooth.interaction.terms
    }

  all.predictors=na.omit(unique(c(all.predictors,pred.vars.fact)))
  # calculate a correlation matrix between all predictors
  if(non.linear.correlations==T){
   cc=check.non.linear.correlations(use.dat[,all.predictors])}else{
   cc=check.correlations(use.dat[,all.predictors])}
  if(length(cor.matrix)==1){
   cor.matrix=cc
   # replace NA's with zero.
   cor.matrix[which(cor.matrix=="NaN")]=0
   cor.matrix[which(is.na(cor.matrix)==T)]=0}else{
      # check if the user defined matrix has the same rownames and colnames
      check.predictors=c(match(all.predictors,colnames(cor.matrix)),
                         match(all.predictors,rownames(cor.matrix)))
      missing.predictors=unique(rep(all.predictors,2)[which(is.na(check.predictors))])
      if(length(missing.predictors)>0){
            stop(paste("Supplied cor.matrix is missing required predictors: ",
            paste(missing.predictors,collapse=", "),".",sep=""))}
  }

  # make all possible combinations
  if(length(na.omit(c(pred.vars.cont,linear.vars,
                      pred.vars.fact)))<max.predictors){
        stop("Model max.predictors is greater than the number of predictors.")}
  all.mods=list()
  for(i in 1:max.predictors){
    all.mods=c(all.mods,
     combn(na.omit(c(pred.vars.cont,pred.vars.fact,
                     linear.vars,
                     interaction.terms,
                     linear.interaction.terms,
                     smooth.smooth.interaction.terms)),
                     i,simplify=F))
  }

  # remove redundant models
  use.mods=all.mods
  for(m in 1:length(all.mods)){
    mod.m=all.mods[[m]]
    mod.terms=unlist(strsplit(unlist(strsplit(unlist(strsplit(mod.m,
                               split=".by.",fixed=T)),
                               split=".t.",fixed=T)),
                               split=".te.",fixed=T))
    n.vars.m=unique(unlist(strsplit(unlist(strsplit(unlist(strsplit(unlist(strsplit(mod.m,
                                  split=".by.",fixed=T)),
                                  split=".I.",fixed=T)),
                                  split=".t.",fixed=T)),
                                  split=".te.",fixed=T)))
    cont.vars=na.omit(na.omit(c(pred.vars.cont,linear.vars))[match(mod.terms,
                                           na.omit(c(pred.vars.cont,linear.vars)))])
    fact.vars=unique(na.omit(pred.vars.fact[match(mod.terms,pred.vars.fact)]))

    # if there are factor vars
    if(length(fact.vars)>0){
      # check that any "by" factor vars are accompanied by a + term in its owns right
      if(max(is.na(match(fact.vars,mod.m)))==1){use.mods[[m]]=NA}}

    # remove the model if the predictors are correlated
    if(length(mod.terms)>1){
     row.index=which(match(rownames(cor.matrix),unique(mod.terms))>0)
     col.index=which(match(colnames(cor.matrix),unique(mod.terms))>0)
     cor.mat.m=cor.matrix[row.index,col.index]
     if(max(abs(cor.mat.m[upper.tri(cor.mat.m)]))>cov.cutoff){use.mods[[m]]=NA}
     if(max(abs(cor.mat.m[lower.tri(cor.mat.m)]))>cov.cutoff){use.mods[[m]]=NA}
    }

    # remove the model if there are more than the number of terms specified in "max.predictors"
    if(length(n.vars.m)>max.predictors){use.mods[[m]]=NA}

    # remove the models if a continuous predictor occurs as a by, or a te, and as a single term
    if(length(cont.vars)>length(unique(cont.vars))){use.mods[[m]]=NA}

  }

  use.mods[which(is.na(use.mods))]=NULL

  use.mods=unique(lapply(use.mods,FUN=sort))

  # now make the models into gamm formula
  if(nchar(null.terms)==0){# if there is no bs='re' random effect random effect
                             # or other null term in the null model
    mod.formula=list(as.formula("~ intercept-1"))}
  if(nchar(null.terms)>0){# to add a bs='re' random effect
    mod.formula=list(null.formula)}

  for(m in 1:length(use.mods)){
     mod.m=use.mods[[m]]
     cont.smooths=mod.m[which(match(mod.m,setdiff(pred.vars.cont,linear.vars))>0)]
     by.smooths=mod.m[grep(".by.",mod.m,fixed=T)]
     te.smooths=mod.m[grep(".te.",mod.m,fixed=T)]
     factor.terms=mod.m[which(match(mod.m,pred.vars.fact)>0)]
     linear.terms=mod.m[which(match(mod.m,linear.vars)>0)]
     linear.interaction.terms=mod.m[grep(paste(linear.vars,".t.",sep=""),mod.m,fixed=T)]
     all.terms.vec=character()

     if(length(cont.smooths>0)){all.terms.vec=c(all.terms.vec,
                  paste("s(",cont.smooths,",k=",k,",bs=",bs.arg,")",sep=""))}
     if(length(by.smooths>0)){all.terms.vec=c(all.terms.vec,
         paste("s(",gsub(".by.",",by=",by.smooths,fixed=T),",k=",k,",bs=",bs.arg,")",sep=""))}
     if(length(te.smooths>0) & class(test.fit)[[1]]!="gamm4"){all.terms.vec=c(all.terms.vec,
         paste("te(",gsub(".te.",",",te.smooths,fixed=T),",k=",k,",bs=",bs.arg,")",sep=""))}
     if(length(te.smooths>0) & class(test.fit)[[1]]=="gamm4"){all.terms.vec=c(all.terms.vec,
         paste("t2(",gsub(".te.",",",te.smooths,fixed=T),",k=",k,",bs=",bs.arg,")",sep=""))}
      if(length(linear.interaction.terms>0)){all.terms.vec=c(all.terms.vec,
               gsub(".t.","*",linear.interaction.terms,fixed=T))}
     if(length(factor.terms>0)){all.terms.vec=c(all.terms.vec,factor.terms)}
     if(length(linear.terms>0)){all.terms.vec=c(all.terms.vec,linear.terms)}
     if(max(is.na(cyclic.vars))!=1){
       for(r in 1:length(cyclic.vars)){
           for(v in 1:length(all.terms.vec)){
             if(length(grep(cyclic.vars[r],all.terms.vec[v]))>0){
                  all.terms.vec[v]=gsub(paste("bs=",bs.arg,sep=""),"bs='cc'",all.terms.vec[v])
                  }}}}
     for(v in 1:length(all.terms.vec)){
         if(length(grep("te(",all.terms.vec[v],fixed=T))>0){
            bs.arg.v=c("","")
            smooth.vars.v=unlist(strsplit(gsub("te(","",all.terms.vec[v],fixed=T),split=","))[1:2]
            var.type.vec=unlist(lapply(smooth.vars.v,FUN=function(x){match(x,cyclic.vars)}))
            bs.arg.v[which(is.na(var.type.vec))]=bs.arg
            bs.arg.v[which(var.type.vec>0)]="'cc'"
            bs.arg.v=paste("bs=c(",paste0(bs.arg.v,collapse=","),")",sep="")
            all.terms.vec[v]=gsub("bs='cc'",bs.arg.v,all.terms.vec[v])
            all.terms.vec[v]=gsub(paste("bs=",bs.arg,sep=""),bs.arg.v,all.terms.vec[v])
         }
     }

     if(nchar(null.terms)==0){# if there is no bs='re' random effect
                                # or other null term in the null model
       formula.m=as.formula(paste("~",
               paste(all.terms.vec,collapse="+")))}
     if(nchar(null.terms)>0){#
       formula.m=as.formula(paste("~",
               paste(c(all.terms.vec,null.terms),collapse="+")))}
     mod.formula=c(mod.formula,list(formula.m))
  }

  names(mod.formula)=c("null",lapply(use.mods,FUN=paste,collapse="+"))

  # Is this too many models?
  n.mods=length(mod.formula)
  return(list(n.mods=n.mods,
              predictor.correlations=cor.matrix,
              mod.formula=mod.formula,
              used.data=use.dat,
              test.fit=test.fit,
              included.vars=included.vars))
} #------------------ end function --------------------------------------------#